//The GPLv3 License (GPLv3)
//
//Copyright (c) 2023 Ciubix8513
//
//This program is free software: you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program.  If not, see <http://www.gnu.org/licenses/>.

use regex::Regex;
pub fn name_regex() -> Regex {
    Regex::new(r"typedef\s+(enum|struct)\s+(\w+)\s*\{").unwrap()
}
pub fn field_regex() -> Regex {
    Regex::new(r"\s*(.+?;?)\s*//!<\s*(.+?)$").unwrap()
}
pub fn field_code_regex() -> Regex {
    Regex::new(r"\s*\[(.+?)\]\s*(.+?)$").unwrap()
}
pub fn additional_data_regex() -> Regex {
    Regex::new(r"(.+?)\s+//\s*\((.+?)\)").unwrap()
}
pub fn signed_data_regex() -> Regex {
    Regex::new(r"(\S*\s*\S*)\s*signed:(\d*)\s*bits:(\d*..\d*)\s*[lm]sb:(.*)\S*").unwrap()
}

//Again don't really need these tests, tested all this regex on the https://regex101.com
//Plus it was originally generated by ChatGPT (Thank you ChatGPT)
#[test]
fn test_additional_data() {
    let input = "this is the comment // (min: 0 max: 100)";
    let re = additional_data_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "this is the comment");
    assert_eq!(captures.get(2).unwrap().as_str(), "min: 0 max: 100");
}
#[test]
fn test_struct_name_weird_whitespaces() {
    let input = "           typedef            struct      employee_struct              {      ";
    let re = name_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "struct");
    assert_eq!(captures.get(2).unwrap().as_str(), "employee_struct");
}
#[test]
fn test_struct_name() {
    let input = "typedef struct employee_struct {";
    let re = name_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "struct");
    assert_eq!(captures.get(2).unwrap().as_str(), "employee_struct");
}

#[test]
fn test_enum_name() {
    let input = "typedef enum employee_struct {";
    let re = name_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "enum");
    assert_eq!(captures.get(2).unwrap().as_str(), "employee_struct");
}

#[test]
fn test_field_enum() {
    let input = "TEST_test = 1, //!< description description";
    let re = field_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "TEST_test = 1,");
    assert_eq!(captures.get(2).unwrap().as_str(), "description description");
}

#[test]
fn test_field_enum_basic() {
    let input = "TEST, //!< description";
    let re = field_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "TEST,");
    assert_eq!(captures.get(2).unwrap().as_str(), "description");
}

#[test]
fn test_field_struct() {
    let input = "test_test Test : 6; //!< description description";
    let re = field_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "test_test Test : 6;");
    assert_eq!(captures.get(2).unwrap().as_str(), "description description");
}

#[test]
fn test_field_code_struct() {
    let input = " [code] description description";
    let re = field_code_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "code");
    assert_eq!(captures.get(2).unwrap().as_str(), "description description");
}

#[test]
fn test_field_enum_struct() {
    let input = "int TEST; //!< description";
    let re = field_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "int TEST;");
    assert_eq!(captures.get(2).unwrap().as_str(), "description");
}

#[test]
fn test_field_enum_basic_cyrillics() {
    let input = "   TEST, //!< описание";
    let re = field_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "TEST,");
    assert_eq!(captures.get(2).unwrap().as_str(), "описание");
}

#[test]
fn test_signed() {
    let input = "min:-324000 max:324000 signed:4 bits:5..19 lsb:0.001\"";
    let re = signed_data_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "min:-324000 max:324000");
    assert_eq!(captures.get(2).unwrap().as_str(), "4");
    assert_eq!(captures.get(3).unwrap().as_str(), "5..19");
    assert_eq!(captures.get(4).unwrap().as_str(), "0.001\"");
}

#[test]
fn test_signed1() {
    let input = "min:-324000 max:324000 signed:4 bits:5..19 msb:0.001\"";
    let re = signed_data_regex();
    assert_eq!(re.is_match(input), true);
    let captures = re.captures(input).unwrap();
    assert_eq!(captures.get(1).unwrap().as_str(), "min:-324000 max:324000");
    assert_eq!(captures.get(2).unwrap().as_str(), "4");
    assert_eq!(captures.get(3).unwrap().as_str(), "5..19");
    assert_eq!(captures.get(4).unwrap().as_str(), "0.001\"");
}
